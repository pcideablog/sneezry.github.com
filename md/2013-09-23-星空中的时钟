不知道大家对[TIWE Watch](http://www.lvzhongfang.com/concepts/tiwe-watch/)是否熟悉，也许看到这个名字没什么感觉，但如果你看到图片可能就会说原来这个就是TIWE Watch啊！最早我是在微博上看到它的，它是由中国设计师设计的一款概念产品，第一次看到它就眼前一亮。设计师说灵感是来自儿时对星空的渴望。

正如其设计师在网站上说的那样，现在还没有一个TIWE Watch被真正制造出来——连样机也木有，也就是说网上的图片全是画出来的（很多人要失望了）~那么既然无法买到，我们不妨用代码写出来一个，总比静态的图片好吧。看一下，这个手表功能很简单，平时是几个白色圆点随机分布在表盘上模拟星空，当有触发事件（TIWE Watch是甩动手臂，我们总不能甩动显示器吧，所以可以用鼠标事件代之）发生时，这些圆点就规则排列成指针和刻度来显示当前时间。OK，说干就干，最直接的思路，来个数组初始化所有圆点，然后随机在表盘大小的圆域上摆放这些圆点。于是短短的几分钟就目标达成了……等等，很多小圆点叠在了一起有木有！原设计不是这样的啊！好吧，我们每摆放一个圆点之前都先对比与已经摆放的圆点之间的距离，如果重叠了就重新生成这个圆点的随机位置……等等，死机了有木有！看来这个随机摆放而不相互重叠的算法不是这么简单的，那么就得好好考虑下了。

其实最简单直观的方法就是摆放圆点之前我们先对表盘圆域进行区域分割，每个区域放一个圆点，这样就不会有重叠的圆点了。思路确定之后就是怎么确定区域分割方案的事情了。对于圆域，我们理所当然想到了极坐标，对于极坐标有两个变量，半径和角度，于是为了迎合极坐标，首先想到的就是按照环形区域分割。

<svg width="500" height="500" version="1.1" xmlns="http://www.w3.org/2000/svg">
<circle cx="250" cy="250" r="50" stroke="gray" stroke-width="1" fill="none"/>
<circle cx="250" cy="250" r="100" stroke="gray" stroke-width="1" fill="none"/>
<circle cx="250" cy="250" r="150" stroke="gray" stroke-width="1" fill="none"/>
<circle cx="250" cy="250" r="200" stroke="gray" stroke-width="1" fill="none"/>
<circle cx="250" cy="250" r="250" stroke="gray" stroke-width="1" fill="none"/>
<line x1="250" y1="250" x2="300" y2="250" stroke="gray" stroke-width="1" />
<line x1="250" y1="250" x2="337" y2="300" stroke="gray" stroke-width="1" />
<line x1="250" y1="250" x2="325" y2="380" stroke="gray" stroke-width="1" />
<line x1="250" y1="250" x2="250" y2="450" stroke="gray" stroke-width="1" />
<line x1="250" y1="250" x2="125" y2="467" stroke="gray" stroke-width="1" />
<text x="305" y="256" fill="gray" font-size="12" font-family="Arial">R0</text>
<text x="342" y="310" fill="gray" font-size="12" font-family="Arial">R1</text>
<text x="325" y="395" fill="gray" font-size="12" font-family="Arial">R2</text>
<text x="245" y="470" fill="gray" font-size="12" font-family="Arial">R3</text>
<text x="110" y="485" fill="gray" font-size="12" font-family="Arial">R4</text>
<text x="245" y="230" fill="gray" font-size="12" font-family="Arial">S0</text>
<text x="245" y="180" fill="gray" font-size="12" font-family="Arial">S1</text>
<text x="245" y="130" fill="gray" font-size="12" font-family="Arial">S2</text>
<text x="245" y="80" fill="gray" font-size="12" font-family="Arial">S3</text>
<text x="245" y="30" fill="gray" font-size="12" font-family="Arial">S4</text>
</svg>

上面这幅图展示了分割的方法。很显然，S0、S1、S2、S3和S4的面积是不相等的，我们在这些区域里摆放圆点的数量应和这些区域面积成正比。环形的面积`S=Pi*(R1^2-R2^2)`，整理下就有`S=PI*(R1-R0)*(R1+R0)`，由于每个环的宽度一致，所以可以令`K=PI*delta(R)`，则`S0:S1:S2:S3:S4=R0:(R0+R1):(R1+R2):(R2+R3)=1:3:5:7:9`，由于我们一共有22个圆点（要是25个就更方便了 - -b），按照这个比例计算，我们分别要在这四个区域摆放1个、3个、4个、6个和8个圆点。而对于每个环形再按照摆放的圆点数按圆心角平分。

既然分割区域的方案也定下来了，下面我们就要进行摆放了。首先要对圆点就行乱序排列，然后再依次摆入上述区域。数列乱序的方法有很多，我说下我所使用的方法。首先随机生成一个100~200之间的随机数（比22大就可以），然后用这个数对22求余，得到数字i，然后将序列为i的圆点从数列中取出入栈新的数列，之后再用这个数对21求余……依次类推，新的数列中保存的就是乱序后的数列。在开始摆放圆点这里我开始用的是if判断，因为每个环形中摆放的圆点数目不同，这是一个分段函数。但这里用分段判断会不会太挫了，秉着将Geek精神发挥到底的目标，要想出一个万能的公式！

下面是高等数学数列部分的讲解时间（有木有要把我拖出去乱棒打死的冲动 - -b）。为了方便直观，我们先考虑摆放25个圆点的情况。对于25个圆点，分别要在每个环形区域中摆放1个、3个、5个、7个和9个圆点，也就是说对于第一个圆点，放入第1个区域，第二、第三、第四个圆点放入第2个区域……直观发现第n个区域要放入2n-1个圆点。那么第N个圆点要放入哪个区域呢？好像陷入了窘境……看来这个数列不行啊，那么我们换个角度考虑，第1个区域放1个圆点，第1个和第2个区域放4个圆点……最后所有区域放入25个圆点，这样似乎就有解决的方法了！1、4、9、16、25正是n^2的形式，这样我们计算sqrt(n)就可以了，对于不是整数的结果，我们向上取整，如`sqrt(2)=1.414`我们取2。这样是不是给出一个N我们就能知道这个圆点应该在哪个环形区域里了！那么我们有22个圆点，不是25啊。没关系，做映射呗，映射公式就是`N=25/22*N'`，其中N'为22个圆点中的序列。还有一个问题就是我们如何得知在摆放这个圆点之前已经有多少圆点也被摆放在这个环形区域了呢？因为这将决定这个圆点位置的角度变量。我们可以另外声明一个数值，以环形区域序列为角标，每摆入一个圆点相应的元素就自增。似乎一切都进行得很顺利呢，结果跑一下发现还是有重叠~哦，对了，每个区域边界处可能会有重叠，解决方法也很简单，我们把边界往里缩一缩嘛。

剩下的就是时间的显示了，这个没什么难的，按照当前时间算好角度就可以了，刻度的摆放就更容易了，只是有个小细节需要注意：canvas中是屏幕左上角为圆点，向下为纵轴正方向，这和我们常用的直角坐标系向上为正方向不同，转为极坐标自然角度正方向也不同。再有就是极坐标中，沿x轴正方形为角度0点（3点方向），而时钟是沿y轴正方形为角度0点（12点方向），这些小细节需要转换一下，否则会出现比旋转90度或者翻转后的结果。

对于圆点的运动，计算出运动前后位置的距离，然后按照既定时间匀速直线过去就好了。

用canvas做动画可能会有些不知所措，因为我们要边计算每个对象的新位置，又要实时输出画面，所以我建议把这两个操作分离开，输出画面用一个函数去定时刷新，这样我们只需专注计算新位置就ok。我做的这个时钟在输出画面上也做了一些优化，即无需变化画面时停止周期输出画面，而当有触发事件触发动画时再开启周期输出画面，也没什么难的，在触发事件那里加几行代码就可以达成，只是这种细节上的考虑应是每个程序员应有的品格。

最后向大家呈现以下最终的效果吧 :-)

<iframe width="550" height="550" src="/works/dotsclock.html" border="none"></iframe>
