Quake III的源码中有一个神奇的开方常数`0x5f3759df`家喻户晓，这个常数出现在`Q_rsqrt`函数中：

    float Q_rsqrt( float number )
    {
      long i;
      float x2, y;
      const float threehalfs = 1.5F;

      x2 = number * 0.5F;
      y  = number;
      i  = * ( long * ) &y;  // evil floating point bit level hacking
      i  = 0x5f3759df - ( i >> 1 ); // what the fuck?
      y  = * ( float * ) &i;
      y  = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration
      // y  = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed

      #ifndef Q3_VM
      #ifdef __linux__
        assert( !isnan(y) ); // bk010122 - FPE?
      #endif
      #endif
      return y;
    }

由于这个常数出现得很突兀，很难让人一下就看懂，所以大家称它为神奇的开方常数。那么让我们详细分析一下这个常数的来历，以及如何推广到其他的公式中。

首先`Q_rsqrt`这个函数计算的是一个平方根的倒数，即返回的是<script type="math/tex">frac{1}{x^2}</script>。`Q_rsqrt`函数的形参`number`是浮点型，之后将`number`数值的一半赋值给变量`x2`，将`number`赋值给变量`y`。然后保持`y`在内存单元中的二进制数据不变，以整型方式重新读取并赋予变量`i`。接着用那个神奇的开方常数减去了`i`数值的一半，并将结果重新赋予变量`i`。最后再保持`i`在内存单元中的二进制数据不变，以浮点型方式重新读取并赋予变量`y`。后面就是我们熟悉的牛顿迭代了。

这里让人匪夷所思的一个是保持内存单元中的二进制数据不变，以整型方式重新读取，另外一个就是那个常数。为了搞清里面的原理，我们必须先搞清同样的二进制数据，分别以整型方式读取和以浮点型方式读取得到的两个数值之间的关系。我们定于以浮点型方式读取的数值为<script type="math/tex">x</script>，以整型方式读取的数值为<script type="math/tex">I_x</script>。下面我们回顾下整型数据在内存中格式的定于：

    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |S|    E    |                M                |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     1     8                     23
由于页面宽度限制，我没有按真实数据画出比特数，真实数字标于下方。

这是一个32比特表示的浮点型数据在内存中存放的格式，最高位`S`是符号位，0代表正数，1代表负数。最后的23位`M`是基数位，中间的8位`E`是指数位，最后浮点数的真实值是在基数`M`的基础上，左右移位得到的，具体如何移位有指数`E`描述。

用数学公式描述，有<script type="math/tex">x=(M*2^{-23}+1)*2^{E-127}</script>。

通常我们把<script type="math/tex">M*2^{-23}</script>重新定于为<script type="math/tex">m_x</script>，把<script type="math/tex">E-127</script>重新定于为<script type="math/tex">e_x</script>。那么有<script type="math/tex">x=(m_x+1)*2^{e_x}</script>。这里的127是由指数位位数`b`决定的，由于我们这里的指数位是8，所以<script type="math/tex">2^{b-1}-1=2^{8-1}-1=127</script>，如果定义<script type="math/tex">B=2^{b-1}-1</script>，则又有<script type="math/tex">e_x=E-B</script>。而<script type="math/tex">M*2^{-23}</script>中的23也显而易见是由基数位位数``l决定的，如果定义<script type="math/tex">L=2^{-l}</script>，则<script type="math/tex">m_x=\frac{M}{L}</script>。

由上面的定义我们可知，<script type="math/tex">0 \leq m_x \leq1</script>。

接下来我们来推导<script type="math/tex">y=\frac{1}{\sqrt{x}}=x^{-\frac{1}{2}}</script>。为了消除根号，我们对等号两边同时以2为底取对数

<script type="math/tex">log_2 y=-\frac{1}{2}log_2 x</script>

将<script type="math/tex">x=(m_x+1)*2^{e_x}</script>与<script type="math/tex">y=(m_y+1)*2^{e_y}</script>带入，有

<script type="math/tex">log_2 (m_y+1)+e_y=-\frac{1}{2}log_2 (m_x+1)-\frac{1}{2}e_x</script>

由于script type="math/tex">0 \leq m_x \leq1</script>，有<script type="math/tex">log_2 (m_x+1) \approx m_x</script>。为了减少误差，定义一个常数<script type="math/tex">\sigma</script>，令<script type="math/tex">log_2 (m_x+1) = m_x+\sigma</script>。同理<script type="math/tex">log_2 (m_y+1) = m_y+\sigma</script>。

为区分<script type="math/tex">x</script>与<script type="math/tex">y</script>的基数与指数，重新定义变量<script type="math/tex">M_x</script>、<script type="math/tex">E_x</script>与<script type="math/tex">M_y</script>、<script type="math/tex">E_y</script>。再将<script type="math/tex">m_x=\frac{M_x}{L}</script>、<script type="math/tex">e_x=E_x-B</script>和<script type="math/tex">m_y=\frac{M_y}{L}</script>、<script type="math/tex">e_y=E_y-B</script>带入上式，有

<script type="math/tex">\frac{M_y}{L}+\sigma+E_y-B=-\frac{1}{2}(\frac{M_x}{L}+\sigma)-\frac{1}{2}(E_y-B)</script>

整理得

<script type="math/tex">M_y+E_yL=\frac{3}{2}(B-\sigma)L-\frac{1}{2}(M_x+E_xL)</script>

注意，<script type="math/tex">M_x+E_xL</script>就是保持浮点数<script type="math/tex">x</script>在内存中二进制数据不变，以整型方式读取得到的数值<script type="math/tex">I_x</script>，同理<script type="math/tex">M_y+E_yL</script>就是<script type="math/tex">I_y</script>。注意到<script type="math/tex">\frac{3}{2}(B-\sigma)L</script>是个常数<script type="math/tex">R</script>，即有

<script type="math/tex">I_y=R-\frac{I_x}{2}</script>

这与前面给出的代码

    i  = 0x5f3759df - ( i >> 1 );

相吻合。

清楚了整个数学过程，我们来试着计算一个数的平方根。根据前面的推导，我们容易有

<script type="math/tex">log_2 (m_y+1)+e_y=\frac{1}{2}log_2 (m_x+1)+\frac{1}{2}e_x</script>

<script type="math/tex">M_y+E_yL=\frac{1}{2}(B-\sigma)L+\frac{1}{2}(M_x+E_xL)</script>

<script type="math/tex">I_y=\frac{R}{3}+\frac{I_x}{2}</script>

于是有

    i  = 0x1fbd1df5 + ( i >> 1 );

同样，我们可以做一次牛顿迭代。由于牛顿迭代是考察<script type="math/tex">f(x)</script>0点的问题，所以我们要将问题转换为求0点的问题。

构建函数<script type="math/tex">f(y)=y^2-x</script>，其中<script type="math/tex">x</script>为要求平方根的浮点数。

由牛顿迭代公式<script type="math/tex">y=y-\frac{f(y)}{f'(y)}</script>有<script type="math/tex">y=\frac{1}{2}(y+\frac{x}{y})</script>。

最后给出开平方快速算法的JS实现代码

    function sqrt(number){
        if(number <= 0){
            return 0;
        }
        var buf = new ArrayBuffer(4);
        var floatBuf = new Float32Array(buf);
        floatBuf[0] = number;
        var intBuf = new Int32Array(buf);
        intBuf[0] = 0x1fbd1df5 + (intBuf[0]>>1);
        return 0.5*(floatBuf[0]+number/floatBuf[0]);
    }

如果你进行测试可能会发现这个函数的速度没有`Math.sqrt`速度快，甚至远远低于系统函数的速度，这是因为JS只能通过`ArrayBuffer`操作内存中的二进制元数据，所以需要将传入的实参转存到新的内存单元中，从而影响了效率。
