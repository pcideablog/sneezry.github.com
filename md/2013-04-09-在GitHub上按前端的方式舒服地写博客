最早我的独立博客托管在DreamHost上，使用它的App应用，后来它关掉了，再后来就搬到了点点。之前[鸟哥](http://www.rebornix.com)也和我一样将博客托管在了DreamHost，但DreamHost关掉之后他就把博客拉到了GitHub。因为当时GitHub对Windows支持得不是很友好，加之我对Linux的命令行操作总是不得要领，所以一直没有去研究。最近GitHub开发出了Windows下的可视化客户端，于是我也加入到了GitHub，虽然有点晚 :P 同时我还把[Dualx](https://github.com/sneezry/Dualx)托管到了GitHub，现在已经有100多人star了我的项目，40多人fork了我的项目，简直是太feel了！

话说回来，今天要讲的是在GitHub是发文章，就是我正在做的事情。别急，我不是说用Jekyll发，那种走正常路的方法网上一大堆图文并茂的教程，我再在这叨咕不是多余就纯粹是为了自我欣赏，没有必要。作为一个以前端自居的程序员，就一定要有彻头彻尾的前端的方法来实现。

顺便说一下，这个站的主题是GitHub提供的，我比较懒，所以索性抓了个官方的主题进行更改，但是整个实现过程是我自己搞出来的。

兜了这么大的圈子，其实没什么神秘的，说到底就是全站使用Ajax，文章与主题分开。这样我更新博客很方便，只要在线新建一个空白文件，起好名字之后在里面写内容就可以了，剩下的什么更新来，样式啦，全是前端自动搞定的~什么？不信？那么我就把整个过程详细地讲讲 ^^3

首先是url的问题，用户通过url向服务器请求资源，服务器将相应资源返回给用户。但是GitHub是个静态资源库，我不想手动把整个HTML文档都写出来（注意，前端是无法自动生成HTML文档并保存在GitHub的服务器中的），那么我怎么才能既让用户访问不同的url又能只访问我的接口文档，并利用接口文档中的js代码调用博客文章并自动整合呢？我使用的是锚点，就是url中的`#`这个符号来传递参数。

锚点本是在页面内进行定位的，了解HTML的同学都清楚改变url中的锚点是不会使浏览器进行跳转的，同时所访问的资源也不会改变。那么通过锚点改变页面内容不会搜索引擎识别吗？换句话说，不同的锚点对搜索引擎来说会被认为是两个不同的页面吗？答案是肯定的，但是需要进行一点修改，就是将普通的锚点`#`改成`#!`，这样搜索引擎就会将其与search（即url中的`?`）的处理方法相同。看到`#!`很熟悉有木有，Twitter就使用过类似的设计有木有~经过我搜索发现这样的设计也有个学名，叫做单页面应用，意思就是整个程序只有这一个页面是入口，通过改变这个页面的锚点来改变页面的内容。这样做的好处是提高浏览速度，同时降低资源消耗。

<span id="fakeurl">我在这个博客中的url设计为`/#!/yr/mo/dy/post_name`，这样就可以动态加载文章了，又对搜索引擎很友好。但是有强迫症的人可能对url中的`/#!/`很是看不上眼，怎么办呢？我们可以通过前端强行更改url，使它看上去正常些。怎么做呢？使用`history.pushState`。`history.pushState`允许前端更改历史状态，其中就允许修改当前浏览历史的url，方法就是`window.history.pushState(state, title, url)`，其中state和title都是可选的，如果我们只想改url，可以只填写url，而state和title都使用null。</span>

但是问题又来了，url是改了，如果用户之间访问改后的url岂不是找不到资源了，因为毕竟我们的真实url中是有锚点信息的啊。别急，GitHub还提供个自定义404页面的功能，我们此时完全可以利用这个功能。首先用户访问那条改后的url，GitHub找不到那个资源就调用了自定义的404页面，我们再通过那个404页面中的js找出用户想要访问哪篇博文，之后跳转过去就好了。因为跳转过去之后，在那个页面中的js又会马上把url转换回去，所以用户很难发现我们在这个过程中所做出的小动作。但是需要注意的是，搜索引擎可就不是那么容易被fake了，因为它看到404之后是不会理会404页面中的js代码的，所以这种方法对搜索引擎不是很友好。另外我觉得GitHub是有url重写的，因为基于Jekyll的小站也不是url就对应真实的文件夹，只是我还没搞明白，如果你对GitHub的url重写过程比较清楚欢迎在下面给我留言 ^^

这个初步工作就作为了，但是我们还有很多问题没有解决。比如点击含有锚点的链接不会刷新页面，默认也不会触发js，第一次敲url肯定没问题，那么之后页面中点击链接怎么办呢？还有就是浏览器的前进后退按钮怎么办呢？处理方法也不难，我们可以通过`window.onpopstate`检测到url的变化，当url变化了之后，我们重新读取锚点信息，之后刷新特定区域就可以了。还有个问题，如果那个页面真的有锚点怎办，比如我要写一篇很长很长的文档，在文档首部就有一个目录，目录通过锚点快速转到相应章节。等等，你看咱们url中的锚点为了兼容搜索引擎是不是改成了`#!`了，而一般为了页面跳转所设的锚点都是`#`，这就好办了，判断`location.hash.substr(1,1)`的值啊，如果是`!`那就刷新呗，如果不是就不刷新呗。但是点完锚点之后url会改变，这个不是我们所希望的，别急，用[前面讲过的方法](#fakeurl)再给它fake回去呗。

一切都搞定了之后似乎还有最后一个问题，Disqus不认啊！因为我们一直是在一个页面上折腾，全部的内容更新也都是Ajax，那么Disqus在所有文章中都会显示相同的评论啊~接着找突破口~于是翻Disqus的文档，于是找到了方法，只要手动设定`disqus_url`这个值就ok了。那么我们每次更新文章的同时更新这个值，并且清空`disqus_thread`元素的`innerHTML`，然后再次加载一次Disqus的js代码就可以了。

等等，文章列表怎么办？每次手动更新会不会太凶残？翻！接着翻文档。哎？GitHub有提供API？查，查文件列表相关的。哈哈，查到了，而且匿名请求API也可以，每小时有60次的权限，但是只要你不更新文章，这个列表API是自动缓存的，一小时内只有第一次请求会消耗次数，之后访问多少次都直接读缓存，当你有更新后再次请求会自动读取最新内容。哇~~~GitHub很关怀有木有！于是果断Ajax请求文件列表搞起~正High的时候……Ajax不允许跨域有木有……捏着鼻子接着翻……PJSON……等等，这玩意是啥，不就是用于跨域的回调形式吗！GitHub你简直是个神！于是列表愉快地被抓到了~那么这个列表是按照更新时间排序吗？不是！是字典排序法~这就是前面我说把url设计出`/#!/yr/mo/dy/post_name`的原因，用日期做前缀，使用字典排序法也会是日期排序法了~

零零散散又写了这么多，虽然不是什么高级的玩意，但是整个过程的思想我都被自己迷倒了（自恋啊~笑~），我也准备把这个框架发到GitHub，这个架设起来简直是零高度了，一堆静态资源丢进去就行了，然后在特定文件夹中添加文本，整个博客就工作起来了，很神奇有木有！到现在我脸上得意的表情还没有被完全抹去……
